<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal Simulator</title>
    <style>
        /* --- CSS Styles: Cyberpunk / Retro Terminal Look --- */
        :root {
            --bg-color: #0d1117;
            --term-color: #0f0;
            --term-glow: #0f0;
            --font-family: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: var(--bg-color);
            color: var(--term-color);
            font-family: var(--font-family);
            overflow: hidden;
        }

        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 10;
        }

        #screen {
            height: 100%;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            text-shadow: 0 0 5px var(--term-glow);
            font-size: 16px;
            line-height: 1.5;
        }

        /* Scrollbar styling */
        #screen::-webkit-scrollbar { width: 10px; }
        #screen::-webkit-scrollbar-thumb { background: #003300; }
        #screen::-webkit-scrollbar-track { background: #000; }

        .output-line {
            white-space: pre-wrap;
            margin-bottom: 5px;
        }

        .input-line {
            display: flex;
            align-items: center;
        }

        .prompt {
            margin-right: 10px;
            font-weight: bold;
            color: #50fa7b; /* Dracula Green */
        }

        #cmd-input {
            background: transparent;
            border: none;
            color: var(--term-color);
            font-family: var(--font-family);
            font-size: 16px;
            text-shadow: 0 0 5px var(--term-glow);
            flex-grow: 1;
            outline: none;
            caret-color: var(--term-color);
        }

        .dir { color: #8be9fd; font-weight: bold; } /* Cyan */
        .file { color: #f8f8f2; } /* Whiteish */
        .error { color: #ff5555; } /* Red */
        .system { color: #bd93f9; } /* Purple */

        /* Boot animation */
        @keyframes flicker {
            0% { opacity: 0.9; }
            50% { opacity: 1.0; }
            100% { opacity: 0.9; }
        }
        body { animation: flicker 0.2s infinite; }
    </style>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="screen" onclick="document.getElementById('cmd-input').focus()">
        <div id="history"></div>
        <div class="input-line">
            <span class="prompt" id="prompt-span">visitor@web-term:~$</span>
            <input type="text" id="cmd-input" autocomplete="off" spellcheck="false" autofocus>
        </div>
    </div>

<script>
    /**
     * --- JavaScript Logic ---
     * 1. FileSystem (FS): Handles the tree structure and IndexedDB persistence.
     * 2. Terminal: Handles UI, Input, and Command Parsing.
     */

    // --- IndexedDB Wrapper ---
    const DB_NAME = "WebTermDB";
    const STORE_NAME = "FileSystem";
    const DB_VERSION = 1;

    class Storage {
        constructor() {
            this.db = null;
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    this.db = e.target.result;
                    if (!this.db.objectStoreNames.contains(STORE_NAME)) {
                        this.db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => {
                    this.db = e.target.result;
                    resolve();
                };
                request.onerror = (e) => reject("DB Error");
            });
        }

        async save(key, data) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, "readwrite");
                const store = tx.objectStore(STORE_NAME);
                store.put(data, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async load(key) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(STORE_NAME, "readonly");
                const store = tx.objectStore(STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject();
            });
        }
    }

    // --- File System Logic ---
    class FileSystem {
        constructor(storage) {
            this.storage = storage;
            // Default structure
            this.root = {
                type: 'dir',
                name: '/',
                children: {
                    'home': {
                        type: 'dir',
                        children: {
                            'guest': {
                                type: 'dir',
                                children: {
                                    'readme.txt': { type: 'file', content: 'Welcome to Web Terminal!\nThis uses IndexedDB for storage.' },
                                    'secrets.txt': { type: 'file', content: 'Top secret info: 42' }
                                }
                            }
                        }
                    },
                    'bin': {
                        type: 'dir',
                        children: {}
                    }
                }
            };
            this.currentPath = ['home', 'guest']; // Start path
        }

        async init() {
            const savedFS = await this.storage.load('fs_root');
            if (savedFS) {
                this.root = savedFS;
            }
            const savedPath = await this.storage.load('fs_path');
            if (savedPath) {
                this.currentPath = savedPath;
            }
            await this.persist();
        }

        async persist() {
            await this.storage.save('fs_root', this.root);
            await this.storage.save('fs_path', this.currentPath);
        }

        async reset() {
            // Delete DB entries manually to reset or just overwrite logic
            await this.storage.save('fs_root', null); // Logic to reload default on next refresh
            location.reload();
        }

        // Helper: Get node at current path or specific path
        getNode(pathArr = this.currentPath) {
            let node = this.root;
            for (let dir of pathArr) {
                if (node.children && node.children[dir]) {
                    node = node.children[dir];
                } else {
                    return null;
                }
            }
            return node;
        }

        // Helper: Resolve path string to array
        resolvePath(pathStr) {
            if (!pathStr) return this.currentPath;
            let parts = pathStr.split('/').filter(p => p.length > 0);
            let tempPath = pathStr.startsWith('/') ? [] : [...this.currentPath];

            for (let part of parts) {
                if (part === '.') continue;
                if (part === '..') {
                    if (tempPath.length > 0) tempPath.pop();
                } else {
                    tempPath.push(part);
                }
            }
            return tempPath;
        }

        ls(args) {
            const targetPath = args[0] ? this.resolvePath(args[0]) : this.currentPath;
            const node = this.getNode(targetPath);
            
            if (!node) return `<span class="error">ls: cannot access '${args[0]}': No such file or directory</span>`;
            if (node.type === 'file') return args[0];

            let output = Object.entries(node.children).map(([name, item]) => {
                return `<span class="${item.type}">${name}${item.type === 'dir' ? '/' : ''}</span>`;
            }).join('  ');
            return output || '(empty)';
        }

        async cd(args) {
            if (!args[0]) {
                this.currentPath = ['home', 'guest']; // default home
                await this.persist();
                return '';
            }
            const targetPath = this.resolvePath(args[0]);
            const node = this.getNode(targetPath);

            if (!node) return `<span class="error">cd: ${args[0]}: No such file or directory</span>`;
            if (node.type !== 'dir') return `<span class="error">cd: ${args[0]}: Not a directory</span>`;

            this.currentPath = targetPath;
            await this.persist();
            return '';
        }

        cat(args) {
            if (!args[0]) return '<span class="error">cat: missing operand</span>';
            const targetPath = this.resolvePath(args[0]);
            
            // The logic implies the last part of path is the filename
            const fileName = targetPath[targetPath.length - 1];
            const dirPath = targetPath.slice(0, -1);
            
            const dirNode = this.getNode(dirPath);
            if (!dirNode || !dirNode.children[fileName]) return `<span class="error">cat: ${args[0]}: No such file or directory</span>`;
            
            const fileNode = dirNode.children[fileName];
            if (fileNode.type === 'dir') return `<span class="error">cat: ${args[0]}: Is a directory</span>`;
            
            return fileNode.content;
        }

        async touch(args) {
            if (!args[0]) return '<span class="error">touch: missing file operand</span>';
            const pathArr = this.resolvePath(args[0]);
            const fileName = pathArr.pop();
            const dirNode = this.getNode(pathArr);

            if (!dirNode) return `<span class="error">touch: cannot touch '${args[0]}': No such directory</span>`;
            
            if (!dirNode.children[fileName]) {
                dirNode.children[fileName] = { type: 'file', content: '' };
                await this.persist();
            }
            return '';
        }

        async mkdir(args) {
            if (!args[0]) return '<span class="error">mkdir: missing operand</span>';
            const pathArr = this.resolvePath(args[0]);
            const dirName = pathArr.pop();
            const dirNode = this.getNode(pathArr);

            if (!dirNode) return `<span class="error">mkdir: cannot create directory '${args[0]}': No such directory</span>`;
            if (dirNode.children[dirName]) return `<span class="error">mkdir: cannot create directory '${args[0]}': File exists</span>`;

            dirNode.children[dirName] = { type: 'dir', children: {} };
            await this.persist();
            return '';
        }

        async rm(args) {
             if (!args[0]) return '<span class="error">rm: missing operand</span>';
             const pathArr = this.resolvePath(args[0]);
             const name = pathArr.pop();
             const dirNode = this.getNode(pathArr);

             if (!dirNode || !dirNode.children[name]) return `<span class="error">rm: cannot remove '${args[0]}': No such file or directory</span>`;
             
             delete dirNode.children[name];
             await this.persist();
             return '';
        }

        pwd() {
            return '/' + this.currentPath.join('/');
        }
    }

    // --- Terminal UI ---
    class Terminal {
        constructor(fileSystem) {
            this.fs = fileSystem;
            this.historyDiv = document.getElementById('history');
            this.input = document.getElementById('cmd-input');
            this.promptSpan = document.getElementById('prompt-span');
            this.cmdHistory = [];
            this.historyIndex = -1;

            this.input.addEventListener('keydown', (e) => this.handleInput(e));
            this.updatePrompt();
        }

        updatePrompt() {
            const path = this.fs.currentPath.length > 0 ? this.fs.currentPath[this.fs.currentPath.length - 1] : '/';
            // Simplified prompt: user@host:CurrentDir$
            this.promptSpan.innerText = `visitor@web-term:${path}$`;
        }

        async print(text, isCommand = false) {
            if (!text) return;
            const line = document.createElement('div');
            line.className = 'output-line';
            line.innerHTML = text;
            this.historyDiv.appendChild(line);
            
            // Scroll to bottom
            const screen = document.getElementById('screen');
            screen.scrollTop = screen.scrollHeight;
        }

        async handleInput(e) {
            if (e.key === 'Enter') {
                const rawInput = this.input.value;
                const parts = rawInput.trim().split(/\s+/);
                const cmd = parts[0];
                const args = parts.slice(1);

                // Print command to history
                this.print(`<span class="prompt">${this.promptSpan.innerText}</span> ${rawInput}`, true);
                
                // Add to history stack
                if (rawInput.trim()) {
                    this.cmdHistory.push(rawInput);
                    this.historyIndex = this.cmdHistory.length;
                }
                
                this.input.value = '';
                await this.execute(cmd, args);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.input.value = this.cmdHistory[this.historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (this.historyIndex < this.cmdHistory.length - 1) {
                    this.historyIndex++;
                    this.input.value = this.cmdHistory[this.historyIndex];
                } else {
                    this.historyIndex = this.cmdHistory.length;
                    this.input.value = '';
                }
            }
        }

        async execute(cmd, args) {
            let output = '';
            switch (cmd) {
                case 'ls': output = this.fs.ls(args); break;
                case 'cd': output = await this.fs.cd(args); this.updatePrompt(); break;
                case 'cat': output = this.fs.cat(args); break;
                case 'pwd': output = this.fs.pwd(); break;
                case 'touch': output = await this.fs.touch(args); break;
                case 'mkdir': output = await this.fs.mkdir(args); break;
                case 'rm': output = await this.fs.rm(args); break;
                case 'clear': 
                    this.historyDiv.innerHTML = ''; 
                    return;
                case 'reset':
                    await this.fs.reset();
                    return;
                case 'help':
                    output = `
<span class="system">Available commands:</span>
  ls [dir]      - List directory content
  cd [dir]      - Change directory
  cat [file]    - Read file content
  touch [file]  - Create empty file
  mkdir [dir]   - Create directory
  rm [target]   - Remove file or directory
  pwd           - Print working directory
  clear         - Clear screen
  reset         - Factory reset file system
`;
                    break;
                case '': break;
                default: output = `<span class="error">${cmd}: command not found</span>`;
            }
            if (output) this.print(output);
        }
    }

    // --- Main ---
    (async function main() {
        const storage = new Storage();
        try {
            await storage.init();
            const fs = new FileSystem(storage);
            await fs.init();
            const term = new Terminal(fs);

            // Intro text
            term.print(`<span class="system">System Booting... OK</span>`);
            term.print(`<span class="system">Mounting IndexedDB Volume... OK</span>`);
            term.print(`Welcome to Web Terminal v1.0. Type <span class="dir">help</span> for commands.`);
            term.print(` `);
        } catch (err) {
            console.error(err);
            document.body.innerHTML = '<h1 style="color:red">Error loading FileSystem. Browser might not support IndexedDB.</h1>';
        }
    })();

</script>
</body>
</html>